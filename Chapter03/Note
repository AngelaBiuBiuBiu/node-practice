Node模块允许你从被引入文件中选择要暴露给程序的函数和变量。
如果模块返回的函数或变量不止一个，那它可以通过设定exports对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定module.exports属性。
如果创建了一个既有exports又有module.exports的模块，那它就会返回module.exports，而exports会被忽略。
最初在程序里导出的是module.exports，exports只是对module.exports的一个全局引用，最初被定义为一个可以添加属性的控对象。所以exports.myFunc只是module.exports.myFunc的简写。
所以，如果把exports设定为别的，就打破了module.exports和exports之间的引用关系。可是因为真正导出的是module.exports，那样exports就不能用了，因为它不再指向module.exports了。
如果你想维持那个链接，可以像下面这样让module.exports再次引用exports：module.exports = exports = Currency;


Node的模块系统避免了对全局作用域的污染，从而也就避免了命名冲突，并简化了代码的重用。
模块还可以发布到npm（Node包管理器）存储库中，这是一个收集了已经可用并且要跟Node社区分享的Node模块的在线存储库，使用这些模块没必要担心某个模块会覆盖其他模块的变量和函数。


模块既可能是一个文件，也可能是包含一个或多个文件的目录。如果模块是一个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口。这个默认设置可以重写。
典型的模块是一个包含exports对象属性定义的文件，这些属性可以是任意类型的数据，比如字符串、对象和函数。


使用模块要用到Node的require函数，该函数以你要用的模块的路径为参数。Node以同步的方式寻找它，定位到这个模块并加载文件的内容。
require是Node中少数几个同步I/O操作之一。因为经常用到模块，并且一般都在文件顶端引入，所以把require做成同步的有助于保持代码的整洁、有序，还能增强可读性。
但是在程序I/O密集的地方尽量不要用require。所有同步调用都会阻塞Node，直到调用完成才能做其他事情。
比如你正在允许一个HTTP服务器，如果在每个进入的请求上都用到了require，就会遇到性能问题。所以通常都只在程序最初加载的时候才使用require和其他同步操作。


Node中有一个独特的模块引入机制，可以不必知道模块在文件系统中的具体位置。这个机制就是node_modules目录。
用环境变量NODE_PATH可以改变Node模块的默认路径。


如果模块是目录，在模块目录中定义模块的文件必须被命名为index.js，除非你在这个目录下一个叫package.json的文件中特别指明.
要指定一个取代index.js的文件，package.json文件里必须有一个用JavaScript对象表示法（JSON）数据定义的对象，其中有一个名为main的键，指明模块目录内主文件的路径。


Node能把模块作为对象缓存起来，如果程序中的两个文件引入了相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。
实际上第二个引入有机会修改缓存的数据，这种“猴子补丁”让一个模块可以改变另一个模块的行为，开发人员可以不用创建它的新版本。

Node的世界里流行两种响应逻辑管理方式：回调和事件监听。
回调通常用来定义一次性响应的逻辑，比如对于数据库查询，可以指定一个回调函数来确定如何处理查询结果。
事件监听器本质上也是一个回调，不同的是，它跟一个概念实体（事件）相关联。当有HTTP请求过来时，HTTP服务器会发出一个请求事件，你可以监听那个请求事件并添加一些响应逻辑。


回调是一个函数，它被当作参数传给异步函数，它描述了异步操作完成之后要做什么。
Node中大多数内置模块在使用回调时都会带两个参数，第一个是用来放可能会发生的错误的，第二个是放结果的。错误参数经常被缩写为er或err。


事件发射器会触发事件，并且在那些事件被触发时能处理它们，事件是通过监听器进行处理的。监听器是跟事件相关联的，带有一个事件出现时就会被触发的回调函数。


让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行。
需要一个接着一个执行的任务叫做串行任务。
不需要一个接着一个做的任务叫做并行任务。这些任务彼此之间开始和结束的时间并不重要，但在后续逻辑执行之前它们应该全部做完。
跟踪串行和并行的流程控制要做好编程记账的工作。在实现串行化流程控制时，需要跟踪当前执行的任务，或维护一个尚未执行任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。


可以使用回调让几个异步任务按顺序执行，但如果任务很多就必须要组织一下，否则过多的回调嵌套会把代码搞的很乱。
串行化流程控制本质上是在需要时让回调进场，而不是简单地把它们嵌套起来。


流程控制可以管理异步任务的执行顺序，可以让它们一个接一个执行，也可以同时执行。
你可以自己实现流程控制，但社区附加模块可以帮你解决这个麻烦。选择哪个流程控制附加模块很大程度上取决于个人喜好以及项目或设计的需要。